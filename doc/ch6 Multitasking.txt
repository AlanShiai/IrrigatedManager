6.1 关于任务和多任务
现代实时系统基于多任务和任务间通信的互补概念。多任务环境允许将实时应用程序构造为一组独立的任务，每个任务具有自己的执行线程和系统资源集。
VxWorks任务是操作系统本身以及作为进程执行的应用程序中代码执行的基本单元。在其他操作系统中，术语“线程”被类似地使用。
多任务为应用程序提供了控制和响应多个离散的真实世界事件的基本机制。VxWorks实时内核提供了一个基本的多任务环境。在单处理器系统上，当内核根据调度策略交错它们的执行时，多任务会产生并发运行的许多线程的外观。在SMP系统中，多任务处理涉及许多执行线程的实际并发。
每个任务都有自己的上下文，这是任务每次被内核调度运行时看到的CPU环境和系统资源。在上下文切换中，任务的上下文保存在任务控制块（TCB）中。任务的上下文包括诸如用户和组ID、执行线程（任务的程序计数器）、CPU寄存器、动态变量堆栈和函数调用等属性。
除了少数例外，VxWorks的对称多处理器（SMP）和单处理器（UP）配置共享相同的API――差别仅相当于几个函数。还要注意，一些编程实践――例如依赖于任务优先级而不是显式锁定的隐式同步技术――不适合SMP系统。
有关SMP编程的信息，请参见18，VxWorks SMP。

6.2 VxWorks系统任务
根据其配置，VxWorks在引导时启动各种系统任务，其中一些任务始终在运行。
基本VxWorks任务
下面将描述与VxWorks的基本配置相关联的一组任务，以及与常用可选组件相关联的一些任务。
注意：不要暂停、删除或更改这些任务的优先级。这样做会导致不可预测的系统行为。

Root Task
任务名称      tRootTask
优先权        0
触发事件      系统启动。
组件          N/A
描述 根任务是内核执行的第一个任务。根任务的入口点是usrRoot(),它初始化大多数VxWorks工具。它生成诸如日志任务、异常任务、网络任务和tRlogind守护进程之类的任务。通常，根任务在所有初始化完成后终止。
参考          VxWorks 7 BSP and Driver Guide.

Logging Task
任务名称      tLogTask
优先权        0
触发事件      A LogMsg()从ISR上下文或任务上下文调用。
组件          INCLUDE_LOGGING
描述          VxWorks模块使用日志任务来记录来自ISR的系统消息和消息，而无需在当前任务上下文中执行I/O。
参考          11.8 Asynchronous Input/Output, p.313 and the logLib API reference.

Exception Task
任务名称      tExcTask
优先权        0
触发事件      从ISR上下文调用excJobAdd()。
组件          INCLUDE_EXC_TASK
描述         异常任务代表ISR执行作业（即函数调用），因为它们不能在中断级别执行。它必须在系统中具有最高优先级。
参考          The excLib API reference entry.

Job Task
任务名称      tJobTask
优先权        0
触发事件      N/A。所有作业都由VxWorks系统设施排队。
组件          INCLUDE_JOB_TASK
描述         任务任务执行任务，函数代表任务调用。它在等待请求时以优先级0运行，并动态调整其优先级以匹配请求作业执行的任务的优先级。其主要目的之一是处理自杀任务删除（即，自我删除的任务）。
参考          6.13 Task Deletion and Deletion Safety, p.100.

SMP ISR Task
任务名称      tIsrN
优先权        0
触发事件      调用isrDeferJobAdd()的设备中断。
组件          INCLUDE_ISR_DEFER
描述         当设备驱动程序执行isrDeferJobAdd()时，tIsrN任务（或任务）代表设备驱动程序执行函数调用。任务名称中的N是延迟任务正在运行的CPU的索引。根据需要创建单独的tIsrN任务，每个任务与CPU N具有CPU亲和性。SMP感知设备驱动程序将中断级处理推迟到在本地CPU上执行的tIsrN任务，以避免跨处理器通信的开销来调度延迟任务。
参考          The isrDeferLib API reference entry

Network Task
任务名称      tIsrN
优先权        50（默认值）。
触发事件      到达、传输完成、网络协议定时器过期、套接字应用程序请求等。
组件          INCLUDE_NET_DAEMON
描述          网络守护进程tNet0为VxWorks网络堆栈执行网络驱动程序和网络协议处理。
参考          Wind River Network Stack Programmer’s Guide.

可选组件的任务
以下任务是在VxWorks的常见配置中找到的一些附加任务的示例。

Kernel Shell Task
任务名称      tShellN
优先权        1（可配置）
触发事件      系统启动（默认）。
组件          INCLUDE_SHELL
描述          内核外壳是作为任务生成的。从内核shell调用（而不是派生）的任何函数或任务都在tShellnum上下文中运行。控制台上的shell的任务名是tShell0。内核shell是重入的，一次可以运行多个shell任务（因此是后缀号）。此外，如果用户远程（使用rlogin或telnet）登录到VxWorks目标，则名称也反映了这一事实。例如，tShellRem1。
参考          VxWorks 7 Kernel Shell User’s Guide.

Kernel Shell Login Task
任务名称      tRlogind
优先权        55
触发事件      新的登录连接。
组件          INCLUDE_RLOGIN
描述          内核shell登录守护进程允许远程用户登录到VxWorks。它接受来自另一个VxWorks或主机系统的远程登录请求，并生成tRlogInTask_hexNum和tRlogOutTask_hexNum（其中hexNum是标识连接的十六进制数）。只要远程用户登录，这些任务就存在。此外，除非在VxWorks 5.5兼容模式下配置shell，否则服务器生成远程shell任务tShellRemdecNum（其中decNum是特定于特定远程shell会话的十进制数）。
参考          VxWorks 7 Kernel Shell User’s Guide.

Kernel Shell Telnet Task
任务名称      ipcom_telnetd
优先权        55
触发事件      新的telnet连接。
组件          INCLUDE_IPTELNETS
描述          描述此守护进程允许远程用户使用telnet登录到VxWorks内核外壳。它接受来自另一个网络主机的远程登录请求。ipcom_telnetd生成其他任务来处理每个传入连接，包括ipcom_telnetspawn、tStdioProxyhexNum和tLoginhexNum（其中hexNum是标识特定连接的十六进制数）。除非在VxWorks 5.5兼容模式下配置shell，否则还会生成远程shell任务tShellRemdecNum（其中decNum是特定于特定远程shell会话的十进制数）。
参考          Wind River Network Stack Programmer's Guide.

RPC Task
任务名称      tPortmapd
优先权        54
触发事件      查询由客户端查找RPC服务。
组件          INCLUDE_RPC
描述          这个守护进程是RPC服务器，充当运行在同一台机器上的RPC服务的中央注册中心。RPC客户端查询守护进程，以查找如何与各种服务器联系。
参考          The rpcLib API reference entry.

TCF Task
任务名称      tTcf
优先权        49
触发事件      tTcfEvent任务请求的阻塞作业
组件          INCLUDE_DEBUG_AGENT
描述          tTcf任务是用于执行阻塞操作的工作者任务。由于无法阻止tTcfEvent任务，所有阻塞操作都推迟到这些任务。工作完成后，结果被发送到tTcfEvent任务来处理数据。

TCF Events Task
任务名称      tTcfEvents
优先权        49
触发事件      TCF客户端请求或目标事件。
组件          INCLUDE_DEBUG_AGENT
描述          tTcfEvents任务处理所有目标事件（如上下文创建和销毁以及断点）。它还处理来自TCF客户端（调试器、调试shell等）的所有请求。事件请求的阻塞操作（例如读取文件描述符）被延迟到以事件的形式将结果发送回tTcfEvents任务的工作任务池。

Debug Task
任务名称      tVxdbgTask
优先权        25
触发事件      给调试工具的VxWorks上下文事件。
组件          INCLUDE_VXDBG
描述          此任务提供到VxWorks调试库（VxDBG事件库）提供的事件支持的接口。此支持由任务级事件延迟设施组成。根据定义，事件是VxWorks上下文事件（例如任务或RTP创建事件、任务或RTP任务停止事件或任务异常事件）的回调函数，必须报告给调试工具（内核shell、Workbench调试器等等）。延迟回调执行是异步的。

6.3 任务的所有者和继承关系
根用户是所有任务和RTP的默认所有者。对于内核和RTP任务，用户和组ID的继承是不同的，可以改变ID。
默认情况下，VxWorks中包括对用户和组标识的支持，其中包含VSB选项USER_IDENTIFICATION_INHERITANCE。
所有任务（内核和RTP）的默认所有者是根用户，对于VxWorks，根用户具有1用户ID和1组ID。根用户也是RTP的默认所有者。内核任务从生成任务的父任务继承用户ID和组ID。RTPS继承产生任务的任务的用户ID和组ID。RTP任务继承其RTP的用户ID和组ID，因此给定RTP中的所有任务具有相同的所有者。然而，如果一个任务改变了它的所有权，它同时改变了RTP中所有任务的所有权，以及RTP本身。
可以使用getuid()和getgid()获得任务的所有权，并使用setuid()和setgid()更改（在某些条件下）。如果任务将其用户ID从根更改为另一个用户，则它失去了再次更改它的能力。也就是说，不属于root的任务不能更改其用户ID或组ID。但是，如果保留了根用户ID，则可以不受限制地更改其组ID。
taskShow()函数可以通过使用0和5作为参数来显示任务用户ID和组ID。PS-L shell命令可以用来显示RTPS的所有权（用户和组ID）。
注意：注意，没有为任务或RTPS提供的特权验证系统。如果您使用所提供的API开发自己的API，那么请注意它不会干扰管理用户权限的VxWorks特性（参见 16 User Authentication and Management, p.399）。

6.4 任务状态与转换
内核维护系统中每个任务的当前状态。由于诸如应用程序进行的某些函数调用（例如，当试图获取不可用的信号量时）以及诸如调试器之类的开发工具的使用等活动，任务从一个状态改变到另一个状态。
处于就绪状态的最高优先级任务是执行的任务。当任务用taskSpawn（）创建时，它们立即进入就绪状态。有关就绪状态的信息，请参见Scheduling and the Ready Queue, p.87.。
当使用taskCreate()创建任务时，或者使用VX_TASK_NOACTIVATE选项参数创建taskOpen()时，将在挂起状态下实例化它们。然后可以用taskActivate（）激活它们，使它们进入就绪状态。激活阶段很快，使应用程序能够创建任务并及时激活它们。
任务状态和状态符号
表6-1描述了使用开发工具时看到的任务状态和状态符号。
注意，任务状态是附加的；任务可能同时处于一个以上的状态。关于多个状态之一，可以发生转换。例如，任务可以从挂起过渡到停顿并停止。如果它不被挂起，它的状态就简单地停止了。
表6-1任务状态符号
状态符号          描述
READY     准备好的任务不是等待CPU以外的任何资源。
PEND      由于某些资源（例如信号量）的不可用，任务被阻塞。
DELAY     任务持续一段时间。
SUSPEND    暂停该任务不可用于执行（但未被挂起或延迟）。此状态主要用于调试。暂停不禁止状态转换，只执行。因此，挂起的暂停任务仍然可以解除阻塞，并且延迟的任务仍然可以唤醒。
STOP      任务由调试器停止（错误检测和报告工具也使用）。
DELAY + S 任务延迟和暂停。
PTEN+S    任务是暂停和暂停。
PEND + T  任务用超时值来填充。
STOP+P    任务被挂起和停止（由调试器、错误检测和报告工具或SIGSTOP信号执行）。
STOP + S  任务（由调试器、错误检测和报告工具，或SIGSTOP信号）并暂停。
STOP+T    任务被延迟和停止（由调试器、错误检测和报告工具或SIGSTOP信号执行）。
PTEN+S+T  任务用超时值挂起并暂停。
STOP+P+S  任务由调试器暂停、暂停和停止。
STOP+P+T  任务以超时暂停，并由调试器停止。
STOP+T+S  任务被调试器暂停、延迟和停止。
ST+P+S+T  任务被暂停，暂停，并由调试器停止。
state+I   任务是由状态（上面列出的任何状态或状态的组合）加上继承的优先级指定的。
当断点被击中时，调试设备使用停止状态。它还用于错误检测和报告设施（更多信息，请参见13. Error Detection and Reporting.）。

shell命令输出中的任务状态示例
这个例子显示了来自i（）shell命令的输出，显示任务状态信息。
-> i
NAME ENTRY TID PRI STATUS PC SP ERRNO DELAY
---------- ------------ -------- --- ---------- -------- -------- ------- -----
tJobTask 601f3bb0 603ec010 0 PEND 602a22bb 60be1f30 0 0
tExcTask 601f35e0 603a4e40 0 PEND 602a22bb 603a4d40 0 0
tLogTask logTask 603ec3e0 0 PEND 6029fdfb 60befec0 0 0
tShell0 shellTask 6058d2a0 1 READY 602aaf60 60d47c50 0 0
ipcom_tick> 600d4110 60d4dc30 20 PEND 602a22bb 60c75f10 0 0
tVxdbgTask 601900b0 60425848 25 PEND 602a22bb 60ce7f40 0 0
tTcfEvents 602511e0 60388560 49 PEND+T 602a22bb 603b2210 0 537
tTcf 601a98e0 60590fc0 49 PEND 602a22bb 60d5b8f0 0 0
tTcf 601a98e0 60591c80 49 PEND 602a22bb 60d6f8f0 0 0
tTcf 601a98e0 605951e0 49 PEND 602a22bb 60d83920 0 0
tAioIoTask> aioIoTask 60404338 50 PEND 602a2ab6 60c15f20 0 0
tAioIoTask> aioIoTask 60408010 50 PEND 602a2ab6 60c27f20 0 0
tNet0 ipcomNetTask 60489b30 50 PEND 602a22bb 60c35f20 0 0
ipcom_sysl> 600d2dd0 60c6dac0 50 PEND 602a2ab6 60c89e50 0 0
tNetConf 6010d980 603fdac8 50 PEND 602a22bb 60cc5d60 0 0
ipcrypto_r> ipcrypto_rn> 60419618 50 DELAY 602a9b97 60cd9f80 0 37
tAnalysisA> cafe_event_> 60374600 50 PEND 602a22bb 6039a2b0 0 0
tAioWait aioWaitTask 60404010 51 PEND 602a22bb 60c03e90 0 0
ipcom_egd 600d1eb0 604201d0 255 DELAY 602a9b97 60c97ea0 0 37
value = 0 = 0x0
-> i

基本任务状态转换说明
图6-1提供了任务状态转换的简化说明。为了清楚起见，它没有显示Tasks States and State Symbols, p.82,中讨论的添加状态，也没有显示调试工具使用的STOP状态。
列出的函数是导致关联转换的示例。例如，称为taskDelay()的任务将从就绪状态移动到延迟状态。
注意，taskSpawn()使任务在创建时进入就绪状态，而taskCreate()使任务在创建时进入挂起状态（使用带有VX_TASK_NOACTIVATE选项的taskOpen()也达到后一目的）。

6.5 任务调度
多任务处理需要一个任务调度器分配CPU到就绪任务。VxWorks提供了几个调度器选项。
选项如下：
■传统的VxWorks调度器，它提供基于优先级的抢占式调度以及循环扩展。参见VxWorksTraditional Scheduler, p.86.。
■VxWorks POSIX线程调度器，它被设计（和需要）用于在进程（RTP）中运行pthread。参见9.18 POSIX and VxWorks Scheduling,
p.208.)。
■RTP时间分区调度器，它允许为指定的时间帧调度RTP本身。参见15.11 RTP Time Partition Scheduling, p.388.
■一个自定义调度器框架，允许您开发自己的调度器。见20. Custom Scheduler。

任务优先级
任务调度依赖于任务的优先级，任务的优先级在创建时被分配。VxWorks内核提供256个优先级，编号为0到255。优先级0是最高的，优先级255是最低的。
虽然任务在创建时被赋予它的优先级，但之后可以以编程方式更改它。有关优先级分配的信息，请参见6.6 Task Creation and Activation, p.90 and 6.12 Task Scheduling Control, p.99。

内核应用任务优先级
所有的应用任务应该在100到255的优先级范围内。
注意：网络应用程序任务可能需要在优先级低于100的情况下运行。有关这方面的信息，请参阅VxWorks Network Stack Programmer’s Guide。

驱动程序任务优先级
与内核应用程序任务（应该在100到255任务优先级范围内）相反，驱动程序支持任务（与ISR相关联）可以在51-99的范围内。
这些任务是至关重要的；例如，如果支持任务在从芯片复制数据时失败，则设备丢失该数据。驱动程序支持任务的示例包括tNet0（VxWorks网络守护程序任务）、HDLC任务等。
系统tNet0的优先级为50，因此不应该将用户任务分配到低于该任务的优先级；如果是，则网络连接可能中断，并阻止使用主机工具的调试能力。

VxWorks传统调度程序
VxWorks传统调度器提供了基于优先级的抢占式调度以及以编程方式启动循环调度的选项。传统的调度器也可以称为原始或本地调度器。
默认情况下，VxWorks中包括传统的调度器，其中包含INCLUDE_VX_TRADITIONAL_SCHEDULER组件。
有关RTP时间分区调度器、POSIX线程调度器和自定义调度器的信息，请参阅15.11 RTP Time Partition Scheduling, p.388, 9.18 POSIX and VxWorks Scheduling, p.208, and 20. Custom Scheduler。

基于优先级的抢占式调度
当任务具有比当前正在运行的任务更高的优先级时，基于优先级的抢占式调度器抢占CPU。因此，内核确保始终将CPU分配给准备运行的最高优先级任务。这意味着如果优先级高于当前任务的任务准备运行，内核立即保存当前任务的上下文，并切换到优先级更高的任务的上下文。例如，在图6-2中，任务t1被高优先级任务t2抢占，而高优先级任务t2又被t3抢占。当T3完成时，T2继续执行。当T2完成执行时，T1继续执行。
这种调度策略的缺点是，当相同优先级的多个任务必须共享处理器时，如果单个任务从未被阻塞，那么它可以篡夺处理器。因此，其他同等优先级的任务永远不会有机会运行。
Round-Robin调度解决了这个问题（关于更多信息，参见Round-Robin Scheduling, p.88.）。

调度与就绪队列
VxWorks调度器维护FIFO就绪队列机制，该机制包括系统中每个优先级级别上准备运行（即，处于就绪状态）的所有任务的列表。当给定优先级的CPU可用时，位于该优先级列表前面的任务执行。
任务在就绪队列中的位置可以根据对它执行的操作而改变，如下所示：
■如果任务被抢占，则调度器运行较高优先级的任务，但是抢占的任务保留其在优先级列表的前面的位置。
■如果任务被挂起、延迟、挂起或停止，则它完全从就绪队列中删除。当它随后准备再次运行时，它被放置在其就绪队列优先级列表的末尾。（有关任务状态和导致它们之间转换的操作的信息，请参阅6.4 Task States and Transitions, p.82).）。
■如果任务优先级被taskPrioritySet()更改，则将其置于新优先级列表的末尾。
■如果基于互斥信号量优先级继承策略（使用选项）临时提高任务的优先级，则在以提升的优先级执行任务之后，返回到其原始优先级列表的末尾。（有关互斥信号量和优先级继承的更多信息，请参阅Priority Inheritance Policy, p.124.。）
任务轮换：将内核任务移到优先级列表的末尾。可以使用taskRotate()函数将内核任务从就绪队列中的优先级列表的前端移到末尾。例如，下面的调用将优先级级别为100的列表前面的任务转移到最后：
taskRotate(100);
要将当前运行的任务转移到其优先级列表的末尾，使用TASK_PRIORITY_SELF作为taskRotate()的参数，而不是优先级级别。
taskRotate()函数可作为轮询调度的替代。它允许程序在准备运行的相同优先级的任务之间控制CPU的共享，而不是让系统以预定相等的间隔这样做。有关循环调度的信息，请参见Round-Robin Scheduling, p.88.。

Round-Robin调度
VxWorks为基于优先级的抢占调度提供了一个循环扩展。循环调度容纳这样的实例，其中给定优先级的多个任务准备运行，并且您希望在这些任务之间共享CPU。
循环算法试图通过使用时间切片来在这些任务之间共享CPU。在将CPU放弃给组中的下一个任务之前，具有相同优先级的任务组中的每个任务在定义的时间间隔或时间片上执行。因此，没有人能够篡改处理器直到被阻塞。请参阅图6至3来说明这一活动。当时间片期满时，任务移动到就绪队列列表中该优先级的最后位置（有关就绪队列的信息，请参阅Scheduling and the Ready Queue, p.87.）。
注意，尽管循环调度在某些操作系统中用于为所有任务（或进程）提供相等的CPU时间，而不管它们的优先级如何，但VxWorks的情况并非如此。基于优先级的抢占基本上不受循环调度的VxWorks实现的影响。任何准备立即运行的高优先级任务都会得到CPU，而不管当前任务是否用它的执行时间片完成。当中断的任务再次运行时，它只是继续使用其未完成的执行时间。

Round-Robin调度与内核应用
对于内核应用程序，循环调度对于所有任务都以不同优先级运行的系统不是必需的。它是为多个任务在同一级别上运行的系统而设计的。
注意，taskRotate（）函数可以用作轮询调度的替代方案。对于希望在准备运行的相同优先级任务之间共享CPU，但是按照程序要求而不是按预定等间隔执行的情况，这是非常有用的。有关更多信息，请参见Task Rotation: Shifting a Kernel Task to End of Priority List, p.87.

Round-Robin调度与RTP应用
对于RTP应用程序，在多个进程中执行相同应用程序的系统中使用循环调度可能是有用的。在这种情况下，多个任务将执行相同的代码，并且有可能任务不会将CPU交给在另一个进程中运行的具有相同优先级的任务（运行相同的二进制文件）。请注意，循环调度是全局性的，并且控制系统中的所有任务（内核和进程）；无法为所选进程设置循环调度。

启用Round-Robin调度
通过调用kernelTimeSlice()启用循环调度，kernelTimeSlice()接受时间片或间隔的参数。它通过使用零作为KelnTimeSLice（）的参数来禁用。

时间片计数与抢占
使用kernelTimeSlice()调用定义的时间片或间隔是允许每个任务在将处理器放弃给另一个等优先级任务之前运行的时间量。因此，任务旋转，每个执行一个相等的时间间隔。在允许运行优先级组中的所有其他任务之前，没有任务获得第二片时间。
如果启用了循环调度，并且为正在执行的任务启用了抢占，则系统滴答处理程序将增加任务的时间片计数。当指定的时间片间隔完成时，系统滴答处理程序清除计数器，并将任务置于就绪队列优先级列表的末尾，以获得其优先级。加入给定优先级组的新任务被放置在该优先级的优先级列表的末尾，它们的运行时计数器被初始化为零。
启用循环调度不会影响任务上下文切换的性能，也不会分配额外的内存。
如果任务在其间隔期间阻塞或被较高优先级的任务抢占，则保存其时间片计数，然后当任务变得有资格执行时恢复其时间片计数。在抢占的情况下，假设没有其他较高优先级的任务准备运行，则一旦较高优先级的任务完成，任务就恢复执行。如果任务阻塞，则将其放在就绪队列列表的末尾，以获得其优先级。如果在循环调度期间禁用抢占，则不增加执行任务的时间片计数。
无论任务是否在整个计时间隔内执行，当系统计时发生时执行的任务都会累计时间片计数。由于高优先级任务或ISR抢占了任务中的CPU时间，任务可以有效地执行总CPU时间比分配的时间片多或少。
图6-3 示出了相同优先级的三个任务的循环调度：T1、T2和T3。任务t2被较高优先级的任务t4抢占，但在完成t4时停止的计数处恢复。


6.6 任务创建和激活
taskLib库提供的函数为任务创建和控制以及检索有关任务的信息提供了手段。
表6-2中列出的函数用于创建任务。
taskSpawn()的参数是新任务的名称（ASCII字符串）、任务的优先级、选项、堆栈大小、主函数地址以及要作为启动参数传递给主函数的10个参数：
id = taskSpawn ( name, priority, options, stacksize, main, arg1, …arg10 );
注意，任务的优先级可以在生成之后改变；参见6.12 Task Scheduling Control, p.99.。
taskSpawn()函数创建新的任务上下文，包括分配堆栈和设置任务环境以调用具有指定参数的主函数（普通函数）。新任务在指定函数的入口处开始执行。
表6-2任务创建函数
功能描述
taskSpawn（）生成（创建并激活）一个新任务。
taskCreate（）创建，但不激活新任务。
taskInit（）初始化一个新的任务（仅内核）。
taskInitExcStk（）在指定的地址（仅内核）中初始化具有堆栈的任务。
taskOpen（）打开一个任务（或者可选地创建一个任务，如果它不存在）。
taskActivate（）激活初始化的任务。
taskOpen()函数提供一个类似于POSIX的API，用于创建任务（带有可选的激活）或获取现有任务的句柄。它还提供将任务创建为公共对象，具有跨所有进程和内核的可见性（参见Public Naming of Tasks for Inter-Process Communication, p.93).）。taskOpen（）函数是最通用的任务创建函数。
taskSpawn()函数包含分配、初始化和激活的下级步骤。初始化和激活函数由函数taskCreate()和taskActivate()提供，但是，Wind River建议仅在需要对分配或激活进行更大控制时才使用这些函数。
内核函数taskInit()和taskInitExcStk()的区别在于taskInit()函数允许指定执行堆栈地址，而taskInitExcStk()允许指定执行堆栈和异常堆栈。
内核任务的静态实例化
表6-2中列出的任务创建函数执行一个动态的两步操作，其中在运行时为任务对象分配内存，然后初始化该对象。内核任务（和其他VxWorks对象）也可以静态地实例化，这意味着它们的内存在编译时被分配给对象，然后在运行时初始化对象。
VX_TASK宏在编译时声明一个任务对象。宏采用两个参数：任务名称及其堆栈大小。与使用taskSpawn()不同，使用taskSpawn()的名称可以是NULL指针，VX_TASK宏强制使用该名称。堆栈大小必须计算为非零值整数值，并且必须是编译时常数。
VX_TASK_INSTANTIATE宏可以与VX_TASK一起用于静态初始化和调度任务，而不是使用其动态等效的taskSpawn()。
或者，VX_TASK_INITIALIZE宏可以与VX_TASK一起用于初始化任务，但保持挂起，直到稍后用taskActivate()函数启动它。
如果任务生成，则VX_TASK_INSTANTIATE返回任务ID，如果不是，则返回错误。同一个任务名称必须与VX_TASK_INSTANTIATE和VX_TASK宏一起使用。例如：
#include <vxWorks.h>
#include <taskLib.h>
VX_TASK(myTask,4096);
int myTaskId;
STATUS initializeFunction (void)
{
myTaskId = VX_TASK_INSTANTIATE(myTask, 100, 0, 4096, pEntry, \
0,1,2,3,4,5,6,7,8,9);
if (myTaskId != ERROR)
return (OK); /* instantiation succeeded */
else
return (ERROR);

为了初始化一个任务，但是将其挂起，直到稍后可以使用VX_TASK_INITIALIZE宏。然后必须使用taskActivate（）函数来运行该任务。VX_TASK_INITIALIZE和taskActivate（）都必须使用相同的参数。例如：
#include <vxWorks.h>
#include <taskLib.h>
VX_TASK(myTask,4096);
int myTaskId;
STATUS initializeFunction (void)
{
myTaskId = VX_TASK_INITIALIZE(myTask, 100, 0, 4096, pEntry, \
0,1,2,3,4,5,6,7,8,9);
if (myTaskId != NULL)
{
taskActivate (myTaskId);
return (OK);
}
else
return (ERROR);
}

有关这些宏和函数的更多信息，请参见taskLib API引用条目。
有关静态实例化的一般信息，请参阅1.5 Static Instantiation of Kernel Objects, p.7.。

6.7 任务名称和ID
如果任务是用taskOpen()创建的，则必须显式地命名（使用任何长度的ASCII字符串）。如果它是用TaskSpAWAN（）创建的，则不必命名它。
当使用taskSpawn()时，为name参数提供一个空指针，从而自动分配唯一的名称。名称是表单tN，其中N是十进制整数，对于没有显式名称创建的每个任务，该整数递增1。关于如何创建任务，任务ID在生成时返回。
为了避免名称冲突，VxWorks使用一个约定，即在从目标开始的任何内核任务名前面加上字母t，从主机开始的任何任务名前面加上字母u。）前缀的字母I。
任务必须以反斜杠开头的名称创建，以便成为整个系统可访问的公共对象（而不仅仅是在创建它的内存上下文中――进程或内核）。有关更多信息，请参见P.93.进程间通信的公共命名。
大多数VxWorks任务函数将任务ID作为指定任务的参数。VxWorks使用0（0）的任务ID总是暗示调用任务的约定。在内核中，任务ID是任务数据结构的4字节句柄。
任务命名规则
在命名任务时应遵循以下规则和准则：
■公共任务的名称必须是唯一的，并且必须以正斜杠（例如/tMyTask）开头。请注意，公共任务在整个系统、所有进程和内核中都可见。有关公共任务的更多信息，请参阅进程间通信的任务的公共命名，p.93。
私有任务的名称应该是唯一的。VxWorks不要求私有任务名称是唯一的，但是最好使用唯一的名称以避免混淆用户。（请注意，私有任务仅在创建私有任务的实体（内核或进程）内可见。）
为了充分利用主机开发工具，任务名称不应与全局可见的函数或变量名称冲突。
任务名称和ID函数
表6- 3中列出的TaskLIB函数管理任务ID和名称。
表6- 3任务名称和ID函数
功能描述
taskName()获取与任务ID（限于调用它的上下文进程或内核）关联的任务名称。
TaskMeToMoIdId（）查找与任务名称关联的任务ID。
TasDySelff（）获取调用任务的ID。
TasQueDeFiffy（）验证指定任务的存在。
注意，对于在进程（RTP）中使用，最好使用taskName()而不是来自进程的taskNameGet()，因为前者不会引起系统调用的开销。
进程间通信的公共命名
VxWorks任务可以创建为私有对象，这些私有对象只能在创建它们的内存空间（内核或进程）内访问；也可以创建为公共对象，这些公共对象在整个系统（内核和所有进程）内都可以访问。任务是作为私有对象创建还是作为公共对象创建，取决于创建时如何命名它们。公共任务必须用前斜杠前缀（例如，/tMyTebug）显式命名。有关命名任务的详细信息，请参阅6.7个任务名称和ID，P.92。
将任务创建为公共对象允许来自其进程外部的其他任务向其发送信号或事件（分别使用taskKill()或eventSend()函数）。
有关详细信息，请参阅7.18进程间与公共对象通信，p.147，VxWorks内核API引用中的taskOpen条目和VxWorks应用程序API引用中的taskLib条目。


6.8 任务选项
6.9 任务栈
6.10 任务信息
6.11 任务执行控制
6.12 任务调度控制
6.13 任务删除和删除安全
6.14 任务扩展：使用钩子函数
6.15 任务错误状态：ErNO
6.16 任务异常处理
6.17 共享代码与重入
6.18 内核任务环境变量

