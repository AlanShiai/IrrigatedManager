4.1 关于静态库、共享库和插件
静态库在编译时链接到应用程序。它们也被称为归档。当加载应用程序时，共享库动态链接到应用程序。它们也被称为动态链接库或DLL。插件在大多数方面与共享库相似，只是它们由应用程序按需（以编程方式）加载，而不是自动加载。共享库和插件通常都称为动态共享对象。
静态库和共享库基本上执行相同的功能。其效用的主要差异如下：
■应用程序所需的静态库的元素（即，特定的.o对象文件）才与应用程序链接。整个库不一定成为系统的一部分。然而，如果一个系统中的多个应用程序（n个数字）使用相同的库元素，那么这些元素在系统中被复制（n次）――在存储介质和系统存储器中。
■当应用程序的任何部分需要时，动态链接器加载整个共享库。（与.o对象文件一样，共享library.so文件是不可分割的单元。）但是，如果系统中的多个应用程序需要共享库，则它们共享单个副本。库代码在系统中不重复。
注意：使用共享库或插件的应用程序必须作为动态可执行文件构建，以便在它们的映像中包括动态链接器。动态链接器在运行时执行动态共享对象和应用程序的绑定。有关这方面的更多信息，请参4.11 RTP Application Development for use With Shared Libraries, p.60 and 4.13 RTP Application Development for use With Plug-Ins, p.61.

共享库和插件的优缺点
动态共享对象共享库和插件都可以提供减少占用空间、灵活性和效率的优点如下
这里使用库来引用这两者，除非特别使用插件：
■由于依赖于共享库的应用程序比应用程序都链接到静态库时要小，所以可以减少系统的存储需求。只需要一组必需的库函数，它们由运行时库文件本身提供。共享库有效使用存储和内存的程度主要取决于有多少应用程序正在使用共享库中的多少，以及应用程序是否同时运行。
■插件在允许应用程序的动态配置方面提供灵活性――它们仅在应用程序需要时才加载（按需编程）。
■共享库是有效的，因为它们的代码在加载到RAM时比标准代码需要更少的重新定位。此外，惰性绑定（也称为惰性重定位或延迟绑定）只允许链接所需的那些函数。
同时，共享库使用位置无关代码（PIC），其略大于标准代码，并且由于通过全局偏移表（GOT）的提供额外间接性，对数据的PIC访问通常比非PIC访问稍慢。这对某些架构的影响比其他架构更大。通常，这种差异大约是百分之几，但是如果共享库中时间敏感的代码路径包含对全局函数、全局数据或常数数据的许多引用，则可能会造成可测量的性能损失。
如果延迟绑定与共享库一起使用，则会引入非确定性行为。（有关惰性绑定的信息，请参阅4.7 Lazy Binding and Shared Libraries, p.55.)）。
共享库的启动成本构成了最大的效率成本（与UNIX的情况一样）。它还比静态可执行文件更复杂，因为内存设置更复杂，I/O（文件访问）也更多。
总之，共享库在下列情况下是最有用的：
■许多程序需要几个库。
■许多使用库同时运行的程序。
■是不使用代码的离散函数单元。
■库代码代表了大量的代码。
相反，当每次仅运行一个应用程序时，或者当应用程序仅使用库提供的功能的一小部分时，不建议使用共享库。

其他考虑
还有许多其他考虑因素可能影响是否使用共享库（或插件）：
■引用全局函数或数据的汇编代码必须手动转换为PIC，以便将其移植到共享库。
该重新定位过程只影响共享库的数据段。因此，使用const C关键字标识的只读数据与数据部分同一段，而不与文本部分同一段，以允许每个可执行文件进行重新定位。这意味着共享库中使用的只读数据在运行时不受错误写操作的保护。
未被编译为PIC的代码不能在共享库中工作。
■已编译为PIC的代码在可执行程序中不起作用，即使可执行程序是动态的。这是因为作为PIC编译的代码中的函数序言是由共享对象中的动态链接器编辑的。
■共享库中的所有构造函数都是同时执行的，因此一个共享库中的高优先级构造函数可以在另一个共享库中的低优先级构造函数比第一个共享库加载晚之后执行。从可执行程序的角度来看，所有共享库构造函数都是在动态链接器的构造函数的优先级级别上执行的。
■如果没有当前正在执行的程序使用它们，则不缓存动态共享对象（它们不会逗留）。因此，如果频繁地加载和卸载共享库，则存在额外的处理器开销。
■并发共享库的数量有一个限制，即1024。由于GOT表具有固定的大小，所以可以使用索引来查找GOT（这使得它更快），所以这个限制被强加了。
警告：在PowerPC上没有支持所谓的远PIC。一些共享库要求全局偏移表大于16384项；因为这大于16位移位的跨度，所以必须使用专用代码来支持此类库。

4.2 共享库和插件的VxWorks配置
虽然共享库和插件只能与RTP（用户模式）应用程序（而不是在内核中）一起使用，但是它们确实需要额外的内核支持来管理不同进程使用它们。
VIP项目相关的组件
默认情况下，VxWorks不提供共享库支持。操作系统必须配置为包含Debug的INCLUDE_SHL组件。
这样做也自动包含这些组件：
■ INCLUDE_RTP包含实时进程支持的主要组件
■ INCLUDE_SHARED_DATA包含存储共享库代码的包含数据
■ INCLUDE_RTP_HOOKS包含共享库初始化的包含钩子
■ 相关的系统调用的各种包含INCLUDE_SC_XYZ组件
还可以使用这些组件包括对相关显示功能的支持：
■ INCLUDE_RTP_SHOW
■ INCLUDE_SHL_SHOW
■ INCLUDE_SHARED_DATA_SHOW
注意，如果使用INCLUDE_SHOW_ROUTINES组件，则自动添加上述三个组件。
配置可以通过使用组件束来简化。BUNDLE_RTP_DEVELOP和BUNDLE_RTP_DEPLOY分别为开发系统和已部署系统提供对共享库的支持（有关更多信息，请参阅4.2 VxWorks Configuration for Shared Libraries and Plug-ins, p.46.）。
有关为实时进程配置VxWorks的一般信息，请参阅共享库和插件的。

4.3 初始化和终止库的开发问题
静态库、共享库和插件的开发都共享一些常见的初始化和终止问题，在设计和开发时必须考虑这些问题。
库与插件初始化
库或插件只有在操作要求在调用其函数之前创建资源（例如信号量或数据区域）时才需要初始化函数。
如果库（或插件）需要初始化函数，那么它的原型应该遵循以下约定：
void fooLibInit (void);
函数不带参数，也不返回任何内容。使用与VxWorks库相同的命名约定可能会很有用；nameLibInit()，其中name是该特性的基名。例如，fooLibInit()将是fooLib的初始化函数。
调用应用程序库初始化的代码由编译器生成。_WRS_CONSTRUCTOR编译器宏必须用于标识库（或插件）的初始化函数（或函数）以及调用它们的顺序。宏采用两个参数，函数名和秩数。函数本身构成宏的主体。
语法如下：
_WRS_CONSTRUCTOR (fooLibInit, rankNumInteger)
{
/* body of the function */
}
下面的示例是创建用于保护稀缺资源的互斥信号量的函数，该互斥信号量可以通过应用程序的各种特征以透明的方式使用。
_WRS_CONSTRUCTOR (scarceResourceInit , 101)
{
/*
* Note: a FIFO mutex is preferable to a priority-based mutex
* since task priority should not play a role in accessing the scarce
* resource.
*/
if ((scarceResourceMutex = semMCreate (SEM_DELETE_SAFE | SEM_Q_FIFO |
SEM_USER)) == NULL)
EDR_USR_FATAL_INJECT (FALSE,
"Cannot enable task protection on scarce resource\n");
}
（有关使用错误检测和报告宏EDR_USR_FATAL_INJECT的信息，请参阅13.7 RTP的其他错误处理选项，p.359）。
编译器使用秩号来初始化初始化函数。（在编译器文档中，秩号称为优先级号。）可以使用从100到65535的秩号-为VxWorks库保留低于100的数字。使用低于100的排序号对内核没有不利影响，但是可能干扰甚至阻止应用程序环境的初始化（这涉及创建资源，如堆、分段等）。
初始化函数按数值顺序（从最低到最高）调用。当分配秩号时，考虑所讨论的库（或插件）是否依赖于在其之前应该调用的任何其他应用程序库。如果是这样，请确保其数量较大。
如果初始化函数被分配相同的秩号，则它们运行的顺序在该秩内是不确定的（即，相对于彼此而言是不确定的）。
C++初始化
在C++中编写的库或插件可能需要对可能使用的任何全局对象初始化静态构造函数，除了在C中编写的代码所需初始化（在库和插件初始化中描述的P.46）之外。
默认情况下，静态构造函数在库（或插件）初始化函数之后最后调用。此外，不能保证库的静态构造函数将在相关应用程序的代码中的任何静态构造函数之前被调用。（从功能上讲，它们都具有last的默认等级，并且在一个等级内没有定义的排序。）
如果需要对静态构造函数的初始化进行排序，可以使用_WRS_CONSTRUCTOR宏显式地对它们进行排序。但是，如果库（或插件）定义的对象和方法被适当设计（使用延迟初始化），那么编写好的C++就不需要特定的初始化功能。
处理初始化失败
库和插件应该设计为对初始化失败做出优雅的响应。在这种情况下，他们应该做到以下几点：
■检查ENOSYS是否已设置，并作出适当响应。对于系统调用，这个errno表示内核中没有包含所需的支持组件。
■释放由初始化函数创建或获得的所有资源。
■使用EDR_USER_FATAL_INJECT注入宏来报告错误。如果系统已经配置了错误检测和报告工具，则将错误记录在错误日志中（并且系统根据工具的配置方式对错误作出响应）。如果系统尚未配置错误检测和报告工具，则尝试通过串行线将消息打印到主机控制台。例如：
if (mutex = semMCreate (SEM_Q_PRIORITY | SEM_INVERSION_SAFE)) == NULL)
{
EDR_USR_FATAL_INJECT (FALSE, "myLib: cannot create mutex. Abort.");
}
有关更多信息，请参见RTPS、P.359的其他13.7个错误处理选项。
共享库和插件删除
共享库和插件在唯一（最后一个）使用它们的进程退出时从内存中删除。当唯一使用它的应用程序调用插件上的dlclose()时，插件也可以显式终止。
使用清除函数
没有库（或插件）终止功能工具可以与初始化功能（特别是关于排名）相媲美。如果除了RTP删除自动发生的操作之外，还需要执行清理操作（例如删除库创建的内核资源），那么必须使用atexit()函数。对atexit()的调用可以在进程生命周期中的任何时间进行，尽管它最好由库（或插件）初始化函数完成。在调用exit()时调用与atexit()注册的清理函数。注意，如果进程的任务直接调用POSIX的_exit()函数，则不会执行向atexit()注册的清理函数。
如果清理是特定于任务或线程的，那么taskDeleteHookAdd()或pthread_cleanup_push()应该用于注册清理处理程序（分别用于VxWorks任务或pthread）。当进程终止时，这些函数按照它们注册的相反顺序执行。
注意：为VxWorks构建的代码只有在基于相同的VSB配置（具有相同的层和版本集）时才是二进制兼容的。此外，内核C++代码必须用与VxWorks映像相同的编译器来构建。

4.4 静态库的开发
静态库（归档）由应用程序可以使用的函数和数据组成，就像共享库一样。然而，当在构建时将应用程序链接到静态库时，链接器会将对象代码（在.o文件中）从库复制到可执行文件中――它们是静态链接的。
另一方面，对于共享库，链接器不执行此复制操作（而是将关于共享库的名称及其运行时位置的信息添加到应用程序中）。
VxWorks开发环境提供了构建静态库（归档）的简单机制，包括一组有用的默认makefile规则。在Workbench和命令行都可以用来构建静态库。


