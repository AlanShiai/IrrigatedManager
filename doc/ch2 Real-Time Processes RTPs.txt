2.1关于实时进程
VxWorks实时进程（RTP）在许多方面类似于其他操作系统中的进程，例如UNIX和Linux，包括广泛的POSIX标准。它们创建、执行、终止的方式都和UNIX进程相似。
VxWorks进程模型是为实时嵌入式系统设计的。支持此模型的特性包括任务全系统调度（默认情况下，进程本身不被调度）、在内核模式和用户模式下抢占进程、分两步创建进程以分离加载和实例化。
VxWorks实时进程提供了在用户模式下执行应用程序。每个进程都有自己的地址空间，其中包含可执行程序、程序的数据、每个任务的堆栈、堆以及与进程本身的管理相关的资源（例如内存分配跟踪）。许多进程可以同时出现在内存中，并且每个进程可以包含多个任务（有时在其他操作系统中称为线程）。
对于64位VxWorks，RTP虚拟内存被重叠，RTP应用程序被构建为绝对可链接的可执行文件。对于32位VxWorks，默认是简单的RTP重叠虚拟内存，但Wind River建议采取额外的方式，将RTPs作为绝对可链接的可执行文件支持的配置步骤。
VxWorks可以被配置为为各个进程提供POSIX PSE52支持。传统的平面RTP虚拟内存配置也可以与32位VxWorks一起使用，但只能使用6.9兼容的BSP。
有关开发RTP应用程序的信息，请参见3 RTP应用程序。

进程与实时进程
一个进程的定义是“可执行的程序”，而VxWorks进程在这方面没有什么不同。事实上，VxWorks实时进程的生命周期与POSIX进程模型在很大程度上是一致的（参见RTP和POSIX，第20页）。
然而，VxWorks进程之所以被称为实时进程（RTP），正是因为它们被设计成支持实时系统所需的确定性。他们这样做的方式如下：
■VxWorks任务调度模型。默认情况下，RTPS没有被调度，任务在整个系统中被全局调度。
■RTP可以工作在内核模式以及用户模式下。每个任务都有一个用户模式和一个内核模式栈。（VxWorks内核是完全抢占的。）
■创建RTP不需要为新进程执行地址空间的副本，然后执行exec操作来加载文件的开销。使用VxWorks，简单地创建一个新的地址空间并加载文件。
■RTP创建分两个阶段进行，这两个阶段清楚地将流程的实例化与加载和执行应用程序分开。第一阶段是在调用RTPSPAWN（）的任务的上下文中执行的。第二阶段由一个单独的任务来执行，该任务承担在执行应用程序文本和数据之前加载应用程序文本和数据的成本，并且以与父任务不同的自身优先级进行操作。父任务（称为rtpSpawn()）不会受到影响，并且不会等待应用程序开始执行，除非它已经被编码为等待。
■RTP 加载程序没有分页要求。
所有这些差异都是为了通过确保确定性而使VxWorks特别适合于硬实时应用程序。因此，VxWorks进程模型与服务器式操作系统（如UNIX和Linux）之间存在差异。这些差异的原因进行了讨论，因为相关的主题在本章中出现。

RTP所有权与继承
所有RTPs和用户模式任务的默认所有者是root用户，对于VxWorks root用户是拥有1的用户ID和1的组ID。RTPs继承产生任务的任务的用户ID和组ID。RTP任务继承了它们的RTP的用户ID和组ID，因此在给定RTP中的所有任务都拥有相同的所有者。然而，如果一个任务改变了它的所有权，它同时改变了RTP中所有任务的所有权，以及RTP本身。
可以使用getuid()和getgid()获得任务的所有权，并使用setuid()和setgid()更改（在某些条件下）。如果任务将其用户ID从root更改为另一个用户，则它失去了再次更改它的能力。也就是说，不属于root的任务不能更改其用户ID或组ID。但是，如果保留了根用户ID，则可以不受限制地更改其组ID。
PS-L shell命令可以用来显示RTPs的所有权（用户和组ID）。
默认情况下，VxWorks中支持用户和组标识，使用USER_IDENTIFICATION_INHERITANCE选项在VSB项目中。
有关内核任务的信息，请参阅6.3任务所有权和继承，P.81.

RTP创建
创建实时进程的过程符合实时系统所需的决定论。RTP的创建发生在两个不同的阶段，当创建进程时，可执行文件被完整加载。在第一阶段，rtpSpawn()调用在系统中创建进程对象，分配虚拟和物理内存给它，并创建初始进程任务（参见RTP和Tasks，p.17）。在第二阶段，初始进程任务加载整个可执行文件并启动主函数。
这种方法以两种符合系统决定论：
■首先，进程创建工作被划分在rtpSpawn()任务和初始进程任务之间，每个进程任务都有自己独特的任务优先级。这意味着加载应用程序的活动不会在请求创建新进程的任务的优先级或CPU时间发生。因此，启动流程的初始阶段是离散的、确定性的，而不管在其中运行的应用程序如何。对于第二阶段，开发人员可以分配适合于应用程序重要性的任务优先级，或者考虑加载应用程序时必须考虑的不确定性约束（例如，如果应用程序是从联网主机系统或本地磁盘加载的）。该应用程序加载与它将运行的优先级相同的任务优先级。在某种程度上，该模型类似于异步I/O，因为调用rtpSpawn()的任务只是启动进程，并且可以在加载和启动应用程序时同时执行其他活动。
■第二，在创建进程时加载整个应用程序可执行文件，这意味着在执行期间不会因增量加载而影响其执行的确定性。当系统被配置为在引导时自动启动应用程序时，该特性显然非常有用――所有可执行文件都已完全加载，并且准备好在系统出现时执行。
rtpSpawn()函数有一个选项，用于为新进程的成功加载和实例化提供同步。
在启动时，按需分配进程（如堆）内部所需的资源。应用程序的文本被保证是写保护的，并且应用程序的数据是可读的和可写的。虽然内存保护是由进程之间的MMU强制分区提供的，但是没有机制通过将进程的内存使用限制到指定数量来提供资源保护。有关更多信息，请参见10 内存管理。
注意，VxWorks进程的创建不涉及复制或共享父进程的页帧（即写即拷贝），就像UNIX和Linux的一些版本一样。有关父进程属性继承问题的信息，请参见RTPs和继承P.18。
有关在进程实例化的每个阶段的具体操作的信息，请参阅rtpLib的API。
VxWorks进程可以通过以下方式启动：
    从内核交互shell
    从Workbench交互
    在boot时候启动
    在应用程序或内核编程启动
有关这方面的更多信息，请参阅3.10 RTP应用程序执行程序P.32。

RTP终止
在下列情况下终止过程：
    当进程中的最后一个任务退出时。
    如果进程中的任何任务调用exit()，则不管进程中是否有其他任务正在运行。    如果进程main()函数返回。这是因为当main()返回时，exit()被隐式调用。可以通过在main()中包括taskExit()调用作为最后一个语句来编写main()生成任务的应用程序，以避免这种行为，并允许其他任务继续操作。见3.10 RTP应用程序执行，P.32。
    如果kill()函数被用来终止进程。 如果在进程上从程序、内核模块、shell的C解释器或Workbench调用rtpDelete()。或者，如果从shell的命令解释器使用rtp delete命令。 如果进程在执行过程中发生异常。为了调试目的，可以更改此默认行为。当错误检测和报告工具被包括在系统中，并且它们被设置为调试模式时，当发生异常时，不会终止进程。
注意，如果进程在shell运行时失败，则将消息打印到shell控制台。可以使用VxWorks错误检测和报告设施记录错误消息（见13 错误检测和报告）。
有关属性继承以及进程资源终止时发生什么的信息，请参阅RTP和继承，第18页。

RTP内存管理
每个RTP都有自己的地址空间，其中包含可执行程序、程序的数据、每个任务的堆栈、堆以及与RTP本身的管理相关的资源（如本地堆管理）。许多RTP可能同时出现在内存中。
每个在系统上运行的RTP都由MMU保护，不被其他RTP破坏。一个RTP的代码、数据和内存仅可被该RTP访问。因此，可以在系统中运行多个同一程序的RTP实例，它们之间产生不希望的副作用。内核和RTP的变量空间和符号空间是分离的。
由于RTP是没有外部引用的完全链接的可执行文件，所以RTP不能调用其他RTP中的函数，也不调用非系统调用的内核函数。

RTP与Task
VxWorks可以同时运行多个RTP，任何数量的RTP都可以运行相同的应用程序可执行文件。也就是说，可以同时运行应用程序的许多实例。
每个RTP可以执行一个或多个Task。当创建RTP时，系统生成一个Task来启动应用程序的执行。然后，应用程序可以产生额外的Task来执行各种功能。RTP内的Task数量没有限制，除了可用内存大小的限制。类似地，对系统中的RTP数量没有限制，但受限于管理并发地址空间的硬件机制（这种机制通常被称为地址空间标识符或ASID）的架构。对于使用ASID或等效机制的目标体系结构，进程的数量仅限于ASID（通常为255）。有关更多信息，请参见VxWorks架构补充。
有关任务的一般信息，请参见6 多任务处理（6. Multitasking）。

RTP中的初始Task
当创建RTP时，生成初始Task以开始执行应用程序。RTP中的初始Task的名称基于可执行文件的名称，并基于以下规则修改：
■以“i”为前缀。
■RTP文件的首字母大写。
■RTP文件扩展名被删除。
例如，当运行FoBab.Vxe时，初始Task的名称是iFoobar。
初始Task为程序的main()函数提供执行的上下文，然后调用它。应用程序本身可以启动其他的任务。

RTP中task的内存管理
Task创建包括从RTP内存空间为任务分配堆栈空间。根据需要，当从内核空闲内存池创建任务时，将自动添加该内存到RTP内存空间。
在用户级库中，RTP中的Task可以使用堆管理API。这些库提供了各种类型的ANSI API，如malloc()和free()。内核为用户空间中的每个进程提供内存池，以便这些函数进行内存管理。
在用户空间中提供堆管理可以提高速度和提高性能，因为应用程序在使用这些还是时候没有系统调用的开销。但是，如果堆用尽，系统自动为进程分配更多的内存（默认情况下），在这种情况下，进行系统调用。环境变量控制堆是否生长。

RTP的调度
默认情况下，VxWorks进程支持确定性的主要方式是，它们本身并不被调度。在VxWorks系统中，使用基于优先级的抢占策略仅调度任务。基于VxWorks内核的强可抢占性，这确保在任何给定时间，准备运行的系统中的最高优先级任务都将执行，而不管任务是在内核中还是在系统中的任何进程中。
VxWorks默认调度程序确实提供了可选的分时能力-循环调度。但是这并不干扰基于优先级的抢占，因此是确定性的。VxWorks循环调度只是确保当有多个具有最高优先级的任务准备同时运行时，在这些任务之间共享CPU。因此，没有人能够篡改处理器直到被阻塞。
相比之下，Windows和Linux等非实时系统的调度策略基于时间共享，以及进程优先级的动态规范，它确保没有进程被拒绝使用CPU的时间过长，并且没有进程垄断CPU。
有关默认VxWorks调度的更多信息，请参阅6.5任务调度，p.85。
有关可选RTP时间分区调度程序的信息，请参阅15.11 RTP时间分区调度，p.388。

进程间通信
虽然每个进程的地址空间对于在其它进程中运行的任务是不可见的，但是任务可以通过使用各种IPC机制（包括公共信号量和公共消息队列）跨进程进行通信。有关更多信息，请参阅7.18 公共对象的进程间通信，第147页。

RTP的继承
VxWorks具有由父/子关系组成的进程层次结构。从内核（无论是通过编程方式、从shell或其他开发工具，还是通过自动启动工具）生成的任何进程都是内核的子进程。由另一个进程产生的任何进程都是该进程的子集。与人一样，在社会中，这些关系对于孩子从父母那里继承了什么特征，以及父母或孩子死后会发生什么至关重要。
VxWorks子进程继承其父的某些属性。子进程继承其父进程的文件描述符（stdin、stdout和stderr），这意味着它们可以访问相同的文件（如果它们是打开的）和信号掩码。但是，如果子进程是由内核启动的，那么子进程只继承三个标准文件描述符。环境变量不是继承的，但是父进程可以将其环境或其子集传递给子进程（关于这方面的信息，请参阅3.6 RTP Environment Variables，p.30）。
虽然信号掩码实际上不是进程的属性，而是任务的属性，但是进程中初始任务的信号掩码是从产生它的任务（即，调用rtpSpawn()函数的任务）继承而来的。如果内核创建了初始任务，则信号掩码为零，并且所有信号都不被阻塞。
getppid()函数返回父进程ID。如果父进程ID是内核，或者父进程ID是死的，则返回NULL。

僵尸进程
默认情况下，当一个进程终止，并且它的父进程不是内核时，它就变成一个僵尸进程。
僵尸进程是“已终止的进程，当其退出状态被报告给等待该进程终止的另一个进程时，该进程被删除”（开放组基础规范问题6，IEEE Std 1003.1，2004版）。
为了响应SIGCHLD信号（每当子进程停止或退出或启动已停止进程时生成SIGCHLD信号）并获得子进程的退出状态，父进程必须在子进程退出或停止之前调用wait()或waitpid()。在这种情况下，父进程被阻塞等待。或者，父节点可以为SIGCHLD设置信号处理器，并在信号处理器中调用wait()或waitpid()。在这种情况下，父节点不会被阻塞。在父进程接收到子进程的退出状态之后，将自动删除僵尸实体。
僵尸的默认行为可以通过以下方式修改：
■通过让父进程不知道子进程的终止，而不创建僵尸。这是通过让父进程忽略SIGCHLD信号来实现的。为此，父进程进行sigaction()调用，将SIGCHLD信号处理程序设置为SIG_IGN。
■通过在终止的子进程退出时不将其转换为僵尸。这可以通过父进程发出sigaction()调用来实现，该调用将sa_flag设置为SA_NOCLDWAIT。


