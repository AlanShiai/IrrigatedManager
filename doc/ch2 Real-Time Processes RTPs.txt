2.1关于实时进程
VxWorks实时进程（RTP）在许多方面类似于其他操作系统中的进程，例如UNIX和Linux，包括广泛的POSIX标准。它们创建、执行、终止的方式都和UNIX进程相似。
VxWorks进程模型是为实时嵌入式系统设计的。支持此模型的特性包括任务全系统调度（默认情况下，进程本身不被调度）、在内核模式和用户模式下抢占进程、分两步创建进程以分离加载和实例化。
VxWorks实时进程提供了在用户模式下执行应用程序。每个进程都有自己的地址空间，其中包含可执行程序、程序的数据、每个任务的堆栈、堆以及与进程本身的管理相关的资源（例如内存分配跟踪）。许多进程可以同时出现在内存中，并且每个进程可以包含多个任务（有时在其他操作系统中称为线程）。
对于64位VxWorks，RTP虚拟内存被重叠，RTP应用程序被构建为绝对可链接的可执行文件。对于32位VxWorks，默认是简单的RTP重叠虚拟内存，但Wind River建议采取额外的方式，将RTPs作为绝对可链接的可执行文件支持的配置步骤。
VxWorks可以被配置为为各个进程提供POSIX PSE52支持。传统的平面RTP虚拟内存配置也可以与32位VxWorks一起使用，但只能使用6.9兼容的BSP。
有关开发RTP应用程序的信息，请参见3 RTP应用程序。

进程与实时进程
一个进程的定义是“可执行的程序”，而VxWorks进程在这方面没有什么不同。事实上，VxWorks实时进程的生命周期与POSIX进程模型在很大程度上是一致的（参见RTP和POSIX，第20页）。
然而，VxWorks进程之所以被称为实时进程（RTP），正是因为它们被设计成支持实时系统所需的确定性。他们这样做的方式如下：
■VxWorks任务调度模型。默认情况下，RTPS没有被调度，任务在整个系统中被全局调度。
■RTP可以工作在内核模式以及用户模式下。每个任务都有一个用户模式和一个内核模式栈。（VxWorks内核是完全抢占的。）
■创建RTP不需要为新进程执行地址空间的副本，然后执行exec操作来加载文件的开销。使用VxWorks，简单地创建一个新的地址空间并加载文件。
■RTP创建分两个阶段进行，这两个阶段清楚地将流程的实例化与加载和执行应用程序分开。第一阶段是在调用RTPSPAWN（）的任务的上下文中执行的。第二阶段由一个单独的任务来执行，该任务承担在执行应用程序文本和数据之前加载应用程序文本和数据的成本，并且以与父任务不同的自身优先级进行操作。父任务（称为rtpSpawn()）不会受到影响，并且不会等待应用程序开始执行，除非它已经被编码为等待。
■RTP 加载程序没有分页要求。
所有这些差异都是为了通过确保确定性而使VxWorks特别适合于硬实时应用程序。因此，VxWorks进程模型与服务器式操作系统（如UNIX和Linux）之间存在差异。这些差异的原因进行了讨论，因为相关的主题在本章中出现。

RTP所有权与继承
所有RTPs和用户模式任务的默认所有者是root用户，对于VxWorks root用户是拥有1的用户ID和1的组ID。RTPs继承产生任务的任务的用户ID和组ID。RTP任务继承了它们的RTP的用户ID和组ID，因此在给定RTP中的所有任务都拥有相同的所有者。然而，如果一个任务改变了它的所有权，它同时改变了RTP中所有任务的所有权，以及RTP本身。
可以使用getuid()和getgid()获得任务的所有权，并使用setuid()和setgid()更改（在某些条件下）。如果任务将其用户ID从root更改为另一个用户，则它失去了再次更改它的能力。也就是说，不属于root的任务不能更改其用户ID或组ID。但是，如果保留了根用户ID，则可以不受限制地更改其组ID。
PS-L shell命令可以用来显示RTPs的所有权（用户和组ID）。
默认情况下，VxWorks中支持用户和组标识，使用USER_IDENTIFICATION_INHERITANCE选项在VSB项目中。
有关内核任务的信息，请参阅6.3任务所有权和继承，P.81.

RTP创建
创建实时进程的过程符合实时系统所需的决定论。RTP的创建发生在两个不同的阶段，当创建进程时，可执行文件被完整加载。在第一阶段，rtpSpawn()调用在系统中创建进程对象，分配虚拟和物理内存给它，并创建初始进程任务（参见RTP和Tasks，p.17）。在第二阶段，初始进程任务加载整个可执行文件并启动主函数。
这种方法以两种符合系统决定论：
■首先，进程创建工作被划分在rtpSpawn()任务和初始进程任务之间，每个进程任务都有自己独特的任务优先级。这意味着加载应用程序的活动不会在请求创建新进程的任务的优先级或CPU时间发生。因此，启动流程的初始阶段是离散的、确定性的，而不管在其中运行的应用程序如何。对于第二阶段，开发人员可以分配适合于应用程序重要性的任务优先级，或者考虑加载应用程序时必须考虑的不确定性约束（例如，如果应用程序是从联网主机系统或本地磁盘加载的）。该应用程序加载与它将运行的优先级相同的任务优先级。在某种程度上，该模型类似于异步I/O，因为调用rtpSpawn()的任务只是启动进程，并且可以在加载和启动应用程序时同时执行其他活动。
■第二，在创建进程时加载整个应用程序可执行文件，这意味着在执行期间不会因增量加载而影响其执行的确定性。当系统被配置为在引导时自动启动应用程序时，该特性显然非常有用――所有可执行文件都已完全加载，并且准备好在系统出现时执行。
rtpSpawn()函数有一个选项，用于为新进程的成功加载和实例化提供同步。
在启动时，按需分配进程（如堆）内部所需的资源。应用程序的文本被保证是写保护的，并且应用程序的数据是可读的和可写的。虽然内存保护是由进程之间的MMU强制分区提供的，但是没有机制通过将进程的内存使用限制到指定数量来提供资源保护。有关更多信息，请参见10 内存管理。
注意，VxWorks进程的创建不涉及复制或共享父进程的页帧（即写即拷贝），就像UNIX和Linux的一些版本一样。有关父进程属性继承问题的信息，请参见RTPs和继承P.18。
有关在进程实例化的每个阶段的具体操作的信息，请参阅rtpLib的API。
VxWorks进程可以通过以下方式启动：
    从内核交互shell
    从Workbench交互
    在boot时候启动
    在应用程序或内核编程启动
有关这方面的更多信息，请参阅3.10 RTP应用程序执行程序P.32。

RTP终止
在下列情况下终止过程：
    当进程中的最后一个任务退出时。
    如果进程中的任何任务调用exit()，则不管进程中是否有其他任务正在运行。    如果进程main()函数返回。这是因为当main()返回时，exit()被隐式调用。可以通过在main()中包括taskExit()调用作为最后一个语句来编写main()生成任务的应用程序，以避免这种行为，并允许其他任务继续操作。见3.10 RTP应用程序执行，P.32。
    如果kill()函数被用来终止进程。 如果在进程上从程序、内核模块、shell的C解释器或Workbench调用rtpDelete()。或者，如果从shell的命令解释器使用rtp delete命令。 如果进程在执行过程中发生异常。为了调试目的，可以更改此默认行为。当错误检测和报告工具被包括在系统中，并且它们被设置为调试模式时，当发生异常时，不会终止进程。
注意，如果进程在shell运行时失败，则将消息打印到shell控制台。可以使用VxWorks错误检测和报告设施记录错误消息（见13 错误检测和报告）。
有关属性继承以及进程资源终止时发生什么的信息，请参阅RTP和继承，第18页。

