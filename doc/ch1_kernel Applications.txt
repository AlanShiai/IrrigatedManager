1.1 关于内核程序
VxWorks内核应用程序以与内核本身相同的模式和内存空间执行。在这方面，它们不同于与其他操作系统（如UNIX和Linux）的应用程序，也不同于VxWorks实时（RTP）应用程序。
内核应用程序可以交互式下载并在VxWorks目标系统上运行，或者与操作系统映像链接并（可选地）配置为在引导时自动执行。
在内核中执行的VxWorks应用程序被创建为可重新定位的对象模块。它们可以更具体地称为基于内核的应用程序模块，但是像本指南中所做的那样，简单地将它们称为内核应用程序模块或内核应用程序通常比较方便。（它们有时在Workbench项目类型可下载内核模块的缩写之后称为DKM，即使它们与内核链接时也是如此。）内核应用程序不应该与作为实时进程（RTP）在用户模式下执行的应用程序混淆。
当构建基于内核的应用程序模块时，将用户代码链接到所需的VxWorks库，并生成ELF二进制文件。内核应用程序使用VxWorks工具，包括定义操作系统接口和数据结构的头文件。
内核应用模块可以是：
通过对象模块加载程序下载并动态链接到操作系统。
与操作系统静态链接，使它们成为系统映像的一部分。
内核模块对于快速开发和调试很有用，因为不需要为应用程序的每次迭代重新构建操作系统映像。该方法也可用于生产系统的诊断设备。各种开发工具，包括调试器和shell（主机或内核），可以用来下载和管理模块。模块可以从内核支持的任何主机文件系统（NFS、FTP等）下载到目标。
内核应用模块也可以存储在Flash或ROM、ROMFS文件系统或磁盘上。一旦加载到目标中，内核应用程序模块就可以从shell或Workbench交互式地启动。
静态链接到操作系统的应用程序模块可以与shell或Workbench交互运行。VxWorks还可以被配置为在启动时自动启动它们。静态连接和自动启动显然适用于生产系统。
在内核空间中运行的应用程序不作为进程执行；它只是在内核空间中运行的另一组任务。内核不保护内核应用程序的任何不当行为的保护，并且应用程序也同样不保护其他内核应用程序的保护，内核模块在超级用户模式下在相同的地址空间中运行。
警告：如果希望将内核应用程序移植到作为实时进程（RTP）执行的用户模式应用程序，则必须确保它满足RTP应用程序的代码要求，并按此进行编译。还必须确保VxWorks配置为对RTPs的支持。有关更多信息，请参见22，内核到RTP应用程序迁移。

内核应用和内核组件需求
VxWorks是一个高度可配置的操作系统。当构建独立于操作系统内核应用程序模块时，构建过程无法确定应用程序最终将在其上运行的VxWorks实例是否已经配置了应用程序所需的所有组件（例如，网络和文件系统）。因此，应用程序代码检查指示内核设施不可用的错误（即，检查API调用的返回值）并做出适当响应是很有用的。当内核应用程序模块与操作系统链接时，构建系统生成关于丢失组件的错误。Workbench和wrtool命令行工具都提供了检查依赖关系并相应地重新配置VxWorks的机制。

二进制文件兼容性
注意：为VxWorks构建的代码只有在基于相同的VSB配置（具有相同的层和版本集）时才是二进制兼容的。此外，内核C++代码必须用与VxWorks映像相同的编译器来构建。
注意：如果模块与VxWorks系统不兼容，内核对象模块加载器将拒绝该模块，打印错误消息，并设置errno（当体系结构不同时设置S_loadElfLib_HDR_READ，或者当其他特性不同时设置S_loadLib_INCOMPATIBLE_MODULE）。

内核应用程序与RTP应用程序的比较
内核应用程序和RTP应用程序之间的主要区别在于，RTP应用程序在单独的受保护的内存环境中运行，而内核应用程序则不是。在各自的环境中还存在的差异有，可用的特性，以及性能、占用空间和内存使用。
VxWorks内核应用程序以内核模式在内核内存空间中运行。它们可以与内核链接，或者在运行时下载到内核中（作为可下载内核模块DKMs）。因为内核应用程序在内核中运行，所以系统不能保护内核免受应用程序方面的不当行为，也不能保护应用程序彼此之间不发生不当行为。在运行时，VxWorks系统任务（如tExcTask）和应用程序任务仅通过它们的优先级和代码的功能来区分。
RTP应用程序在用户模式下作为实时进程执行，每个进程都在它们自己的受保护内存空间中，该内存空间与其他RTP应用程序和内核分开。当该保护是系统的关键考虑时，应使用RTP应用程序。RTP应用程序是独立于内核构建和存储的（在开发期间在主机上以及部署系统的目标上）。VxWorks RTP应用程序与UNIX和Linux等其他操作系统的应用程序类似，只是VxWorks实时进程是为实时系统设计的（有关这方面的更多信息，请参阅2.实时过程：RTPs）。
内核应用程序环境和RTP应用程序环境具有许多相同的特性，但是可用的特性方面也有所不同。例如，驱动程序只能安装在内核中，而PTE52一致性只能在RTP环境中实现。
虽然在内核环境或RTP环境中执行代码的速度没有内在的差异，但是它可能受到代码优化（尽管在RTP环境中影响较小）和系统调用（特定于RTP环境）的使用的影响。尤其使用系统调用（通常是这种情况）的RTP应用程序比类似的内核应用程序慢。此外，VSB项目可用于从各种VxWorks库中删除RTP处理代码（使用Real-Time Process选项），这提高了这些库的性能并减小了它们的大小。
此外，配置有RTP支持组件的VxWorks图像将略大于不支持RTX支持组件的VxWorks图像。而且，对于采用RTP应用程序的系统，总体内存需求通常比可比较的内核应用程序的系统大，因为RTP应用程序包括用户端库（它复制了内核中已经包括的库）。

1.2 C和C++库
VxWorks本地C库和Dinkum C和C++库都是为VxWorks应用程序开发提供的。
使用VxWorks本地C库和Dinkum库
VxWorks本地库用于C内核应用程序开发，Dinkum库在所有其他情况下使用。
VxWorks本机C库提供ANSI规范之外的功能。注意，它们不支持宽字符或多字节字符。
有关这些库的更多信息，请参见VxWorks和Dinkum API引用。有关C++设施的更多信息，请参见5 C++开发。

1.3 内核程序的结构
内核应用程序代码类似于普通的C或C++应用程序，除了它不需要传统的main函数（不像VxWorks基于进程的应用程序）。它只需要一个入口点函数，启动应用程序运行所需的所有任务。
程序入口点函数
入口点函数执行数据初始化，并启动运行中的应用程序使用的所有任务。
注意：如果内核应用程序包含一个main函数，则不要假定它将自动启动。下载或简单地存储在系统映像中的内核应用程序模块必须以交互方式启动（或者由已经运行的另一个应用程序启动）。操作系统还可以被配置为在引导时自动启动应用程序（参见使用userAppInit()自动运行应用程序的1.8）。
例如，内核应用程序可能有一个名为 MyAppStudio，它可能看起来像这样：
void myAppStartUp (void)
    {
    runFoo();
    tidThis = taskSpawn("tThis", 200, 0, STACK_SIZE,
    (FUNCPTR) thisFunction,0,0,0,0,0,0,0,0,0,0);
    tidThat = taskSpawn("tThat", 220, 0, STACK_SIZE,
    (FUNCPTR) thatFunction,0,0,0,0,0,0,0,0,0,0);
    tidAnother = taskSpawn("tAnother", 230, 0, STACK_SIZE,
    (FUNCPTR) anotherFunction,0,0,0,0,0,0,0,0,0,0);
    return (OK);
    }
有关VxWorks任务和多任务的信息，请参见6, 多任务处理。有关使用C++的信息见5, C++开发。
加载内核程序和终止内核程序的回调函数
如果打算在运行时将内核应用程序模块下载到VxWorks，则可以通过实现_VxModuleAutoInit()函数作为入口点，并使用带有loadModule.()的LOAD_CALL_INIT_AUTO选项，让加载程序自动启动它。还可以使用LOAD_CALL_INIT_MANUAL选项，以便在不自动调用初始化函数的情况下加载模块。类似地，可以使用UNLD_CALL_TERM_AUTO选项的unldByModuleId()函数实现_VxModuleAutoTerm()函数，该函数在卸载模块时自动调用。有关更多信息，请参见LoopLIB和UNLDLIB API。

1.4 VxWorks 头文件
许多内核应用程序使用VxWorks操作系统工具类或程序库。这需要源模块引用VxWorks头文件。

VxWorks系统头文件
VxWorks的头文件为所有的全局VxWorks函数提供ANSI C函数原型声明。VxWorks提供了ANSI X3.159―1989标准所指定的所有头文件。
VxWorks系统头文件被复制到VSB项目目录，位于VSBProjutdir/KrnL/h。
VxWorks的头文件：vxWorks.h

头文件 vxWorks.h 必须首先包含在使用VxWorks工具类的每个内核应用程序模块中。它包含许多其他VxWorks模块广泛使用的基本定义和类型。许多其他VxWorks头文件都需要这些定义。包含vxWorks.h，以下行：
#include <vxWorks.h>

VxWorks嵌套头文件
一些VxWorks设备使用其他的、较低级别的VxWorks工具类。例如，TTY管理工具使用环形缓冲库。TTY头文件TyLIb.h使用由环缓冲头文件RNGLYB.H提供的定义。
要求意识到头文件依赖性和排序，这是非常不方便的，所有VxWorks标头文件显式地包含所有必备的头文件。头文件tyLib.h本身包含头文件rngLib.h（基本的VxWorks头文件vxWorks.h，所有其他头文件都假定已经包含它）。
通常，显式地包含必备头文件会带来问题：头文件可能被包含多次并产生致命的编译错误（因为C预处理器将重复定义视为潜在的冲突源）。然而，所有VxWorks头文件都包含有条件的编译语句和定义，这些语句和定义确保它们的文本只包含一次，而不管include语句指定了多少次。因此，内核应用程序模块可以只包括它直接需要的那些头文件，而不考虑相互依赖或排序，并且不会出现冲突。

VxWorks私有头文件
VxWorks的一些元素是可能会改变的内部细节，因此不应在内核应用程序中引用。模块功能的唯一支持用途是通过头文件中的公共定义以及模块的功能接口。依附性确保应用程序代码不受VxWorks模块实现中内部更改的影响。
一些头文件使用HIDDEN注释标记：
    /* HIDDEN */
    ...
    /* END HIDDEN */
内部细节也隐藏在私有的头文件中，这些文件位于私有的目录中。私有头文件的名称与公共头文件具有相同的根，但加上P。例如，semLib的私有头文件是semLibP.h。

头文件和extern "C" 申明
不要在 extern "C" 语句括号内包含系统头文件。所有的VxWorks系统头文件都已经配置成与C和C++编译器一起使用。如果在整个头文件的内容上强制C链接，则可能会在VxWorks头中无效。以下是不正确的：
    #ifdef _cplusplus
    extern "C" {
    #endif
    
    #include <stdio.h>
应该使用下面的写法：
    #include <stdio.h>
    
    #ifdef _cplusplus
    extern "C" {
    #endif
另外，在C++源文件中不要把头文件包含在extern "C"申明语句中。以下是不正确的：
    extern "C" {
    #include <stdio.h>
    }
应该使用下面的写法：
    #include <stdio.h>

1.5 内核对象的静态实例化    