3.1 关于RTP程序
实时进程（RTP）应用程序与其他操作系统（如UNIX和Linux）用户模式应用程序相似。
在开始开发RTP应用程序之前，您应该了解RTP应用程序在执行过程中的行为，即进程。有关RTP调度、创建和终止、内存、任务等的信息，请参阅2.实时处理：RTPs。
实时进程（RTP）应用程序有一个简单的结构要求，这是其他操作系统上的C程序所共有的，它们必须包含main()函数。VxWorks为应用程序开发提供了C和C++库，内核通过系统调用为用户模式应用程序提供服务。
RTP应用程序是作为绝对链接的对象构建的，独立于VxWorks操作系统，使用主机系统上的交叉开发工具。构建应用程序时，用户代码链接到所需的VxWorks应用程序API库，并生成一个ELF可执行文件。按照惯例，VxWorks RTP可执行文件以.vxe文件名扩展名命名。扩展名使用VxWorks中的vx和可执行文件中的e来表示文件的性质。
应用程序创建为完全链接或部分链接的可执行文件，这取决于它们的使用（部分链接的可执行文件与共享库一起使用）。
在开发期间，可以从VxWorks shell或Workbench来执行应用程序。应用程序也可以以编程方式启动，系统可以配置为在已部署系统的引导时自动启动应用程序。对于具有多个应用程序的系统，并非所有的系统都必须在启动时启动。它们可以稍后由其他应用程序启动，或者由用户交互地启动。开发人员还可以实现他们自己的应用程序启动管理器。
VxWorks应用程序可以从内核支持的任何文件系统（NFS、ftp等）加载。RTP可执行文件可以存储在磁盘、RAM、闪存或ROM中。它们可以存储在目标上或通过网络连接可访问的任何地方。
此外，应用程序可以使用ROMFS文件系统与操作系统绑定到一个映像中。ROMFS技术对于部署的系统尤其有用。它允许开发人员将应用程序可执行文件与VxWorks映像绑定到一个系统映像中。与其他操作系统不同，不需要根文件系统（例如，在NFS或磁盘上）来保存应用程序二进制文件、配置文件等。

VxWorks中UP和SMP配置的RTP程序
RTP应用程序可用于VxWorks的单处理器（UP）和对称多处理（SMP）配置。但是，它们必须只使用VxWorks SMP提供的API的子集，使用__thread存储类而不是tlsLib函数，并且专门针对的系统（SMP或UP）进行编译。
注意：为VxWorks构建的代码只有在基于相同的VSB配置（具有相同的层和版本）时才是二进制兼容的。此外，内核C++代码必须用与VxWorks映像相同的编译器来构建。

RTP程序的内核组件需求
RTP应用程序需要VxWorks内核支持。有关为RTP配置VxWorks的信息，请参阅2.2为实时进程配置VxWorks，第20页。
注意：因为RTP应用程序是独立于操作系统构建的，所以构建过程无法确定应用程序最终将在其上运行的VxWorks的实例是否已经配置了应用程序所需的所有组件。因此，应用程序代码必须检查指示内核设施不可用的错误并做出适当的响应。有关更多信息，请参阅3.7个RTPS和所需的内核支持P.31。

RTP程序的存储
RTP可执行文件可以存储在目标系统上的VxWorks  ROMFS文件系统中、主机开发系统上或目标系统可访问的任何其他文件系统（例如，网络上的另一个工作站）上。
启动机制和存储位置的各种组合可用于开发系统和部署的产品。例如，在主机系统上存储应用程序可执行文件并使用内核shell运行它们，对于开发的早期阶段是理想的，因为RTP程序重新编译和启动RTP程序都很容易。另一方面，可以配置和构建到最终产品，以便应用程序与操作系统捆绑在一起，并在系统引导时自动启动，与主机和硬盘驱动器无关。
注意：如果没有提供RTP可执行文件的路径和名称，或者当使用指定的路径找不到可执行文件时，将生成错误S_rtp_INVALID_FILE。如果文件没有存储在目标系统上，则从目标本身的角度来看，路径必须是有效的。有关这方面的信息，请参阅11.4远程文件系统访问VxWorks，p.294。

DKM与RTP程序的比较
DKM和RTP程序之间的主要区别在于，RTP程序在单独的受保护的内存环境中执行，而内核应用程序则不是。每个环境中可用的特性也存在差异，以及性能、占用空间和内存使用方面的差异。
VxWorks内核应用程序以内核模式在内核内存空间中执行。它们可以与内核链接或在运行时下载到内核中（作为可下载的内核模块-DKM）。因为内核应用程序在内核中执行，所以系统不能保护内核免受应用程序方面的不当行为，也不能保护应用程序彼此之间发生不当行为。在运行时，VxWorks系统任务（如tExcTask）和应用程序任务仅通过它们的优先级和代码的功能来区分。
RTP应用程序在用户模式下作为实时进程执行，每个进程都在它们自己的受保护内存空间中，该内存空间与其他RTP应用程序和内核分开。当这种保护是系统的主要考虑因素时，应该使用RTP应用程序。RTP应用程序是独立于内核构建和存储的（在开发期间在主机上以及部署系统的目标上）。VxWorks RTP应用程序与UNIX和Linux等其他操作系统的应用程序类似，只是VxWorks实时进程是为实时系统设计的（有关这方面的更多信息，请参阅2）。实时过程：RTPs）。
内核应用程序环境和RTP应用程序环境具有许多相同的特性，但是在每个中可用的特性方面也有所不同。例如，驱动程序只能安装在内核中，而PSE52一致性只能在RTP环境中实现。
虽然在内核环境或RTP环境中执行代码的速度没有内在的差异，但是它可能受到代码优化（尽管在RTP环境中影响较小）和系统调用（特定于RTP环境）的使用的影响。显著使用系统调用（通常是这种情况）的RTP应用程序比类似的内核应用程序慢。此外，VSB项目可用于从各种VxWorks库中删除RTP处理代码（使用Real-Time Process选项），这提高了这些库的性能并减小了它们的大小。
此外，配置有RTP支持组件的VxWorks映像将比没有配置的稍大。而且，对于采用RTP应用程序的系统，总体内存需求通常比使用可比较的内核应用程序的系统大，因为RTP应用程序包括用户端库（它复制了内核中已经包括的库）。

3.2 RTP程序的结构
VxWorks RTP应用程序有一个简单的结构要求，这是其他操作系统上的C程序所共有的，它们必须包含main()函数。
main()函数可用于常规argc和argv参数以及可选的envp参数：
int main
	(
	int argc, /* number of arguments */
	char * argv[], /* null-terminated array of argument strings */
	char * envp[], /* null-terminated array of environment variable strings */
	);
参数argv[0]表示的运行的相对路径。
注意：虽然VxWorks支持RTP应用程序的envp参数main()，但是Wind River建议您不要使用它。如果RTP的环境变量数组被重新定位（如果在数组中没有剩余空间用于新的环境变量，则可能出现这种情况），则指针无效。

3.3 RTP程序和多任务
如果应用程序是多线程的（具有多个任务），则开发人员必须确保main()函数任务启动所有其他任务。
VxWorks可以同时运行一个或多个应用程序。每个应用程序可以启动多个任务，以及其他进程。RTP程序任务由内核调度，独立于它们执行的进程――进程本身不被调度。从某种意义上讲，进程可以看作任务的容器。
在开发多个应用程序将在其中运行的系统时，开发人员因此应当考虑：
■在所有不同的进程中运行的任务的优先级
■进程之间以及进程内的任何任务同步要求
有关任务优先级和同步的信息，请参阅6.1“关于任务和多任务处理”，第76页。

3.4 VxWorks 头文件
RTP应用程序通常使用VxWorks操作系统程序库。这通常要求源代码引用VxWorks头文件。
VxWorks头文件为所有全局VxWorks函数提供ANSI C函数原型声明。VxWorks提供了ANSI X3.159―1989标准所指定的所有头文件。
VxWorks系统头文件被复制到VSB项目下vsbProjectDir/usr/h的目录。
注意：在RTP应用程序中不要引用内核代码的头文件（参见1.4 VxWorks头文件，p.5）。

POSIX头文件
传统上，VxWorks提供了许多由POSIX.1描述的头文件，尽管它们的内容仅部分符合该标准。对于用户模式应用程序，POSIX头文件在内容和位置上都更严格地符合POSIX.1描述。请参阅用户级标准C库：LIBC，P.184以获取更多信息。

VxWorks的头文件：vxWorks.h
在所有应用程序模块中包含头文件vxWorks.h通常很有用，以便利用特定于体系结构的VxWorks程序库。许多其他的VxWorks头文件也需要这些定义。包含vxWorks.h，以下行：
#include <vxWorks.h>
注意：在任何其他头文件之前，必须将vxWorks.h头文件包括在RTP应用程序中。这个头文件提供了许多VxWorks工具使用的基本定义和类型。它也需要许多其他的VxWorks头文件。
此规则的唯一例外是RTP应用程序必须符合POSIX PSE52配置文件。在这种情况下，不要包含vxWorks.h。与PIS52配置文件不一致的应用程序。

VxWorks嵌套头文件
一些VxWorks设备使用其他的、较低级别的VxWorks工具库。例如，TTY管理工具使用环形缓冲库。tty头文件tyLib.h使用由环形缓冲区头文件rngLib.h提供的定义。
要求您知道这样的包含文件相互依赖和排序是不方便的。相反，所有VxWorks头文件都显式地包括所有必备头文件。因此，tyLib.h本身包含rngLib.h的包含（一个例外是基本的VxWorks头文件vxWorks.h，所有其他头文件都假定它已经包含）。
通常，显式地包含必备头文件会带来问题：头文件可能被包含多次并产生致命的编译错误（因为C预处理器将重复定义视为潜在的冲突源）。然而，所有VxWorks头文件都包含有条件的编译语句和定义，这些语句和定义确保它们的文本只包含一次，而不管include语句指定了多少次。因此，应用程序可以只包含它直接需要的那些头文件，而不考虑相互依赖或排序，并且不会发生冲突。

VxWorks私有头文件
VxWorks的一些元素是可能改变的内部细节，因此不应该在应用程序中引用。VxWorks工具的唯一支持用途是通过头文件中的公共定义以及公共API。您的依附性确保应用程序代码不受内部影响。
VxWorks工具实现的更改。
一些头文件使用隐藏注释标记内部细节：
	/* HIDDEN */
	...
	/* END HIDDEN */
内部细节也隐藏在私有头文件中，这些文件位于名为..私有头文件的名称具有与公共头文件相同的根，但添加了P。例如，semLib的私有头文件是semLibP.h。

头文件和外部“C”语句
不要在extern "C"语句括号内包含系统头文件。所有的VxWorks系统头文件都已经配置成与C和C++编译器一起使用。如果强制对整个头文件的内容进行C链接，则可以使VxWorks头中的声明无效。以下是不正确的：
	#ifdef _cplusplus
	extern "C" {
	#endif
	#include <stdio.h>
但以下是正确的：
	#include <stdio.h>
	#ifdef _cplusplus
	extern "C" {
	#endif
此外，不要在C++文件中的外部“C”语句中包含VxWorks头文件。以下是不正确的：
	extern "C" {
	#include <stdio.h>
	}
但这是正确的：
	#include <stdio.h>

3.5 RTP程序：系统调用和库函数
VxWorks为开发RTP应用提供了一套广泛的API。与其他操作系统一样，这些API包括系统调用和库函数。
一些库函数包括系统调用，而其他函数完全在用户空间中执行。注意，为RTP应用程序提供的用户模式库与内核库完全分离。一些API对进程而不是任务级别进行操作，例如，kill()和exit()。
VxWorks系统调用
因为内核模式和用户模式具有不同的指令集和MMU设置，所以在用户模式下运行的RTP应用程序不能直接访问内核函数和数据结构。系统调用提供了应用程序请求内核代表应用程序执行服务的方法，这通常涉及对内核或硬件资源的操作。
系统调用对用户是透明的，但是操作如下：对于每个系统调用，执行特定于体系结构的陷阱操作以将CPU特权级别从用户模式更改为内核模式。完成陷阱请求的操作后，内核从陷阱返回，将CPU恢复到用户模式。因为它们涉及对内核的陷阱，所以系统调用比完全在用户模式下执行的库函数具有更高的开销。
注意，如果配置VxWorks时没有提供应用程序所需的系统调用的组件，则对应的用户模式库API将ENOSYS作为errno返回。
还要注意，如果系统调用已经捕获到内核，并且在接收到信号时正在等待系统资源，则可能会中止系统调用。在这种情况下，ENOSYS可以返回给API的调用方。
系统调用在VxWorks API引用中被标识为这样。
VxWorks提供的一组系统调用可以由内核开发人员扩展。它们可以向操作系统添加自己的工具，并通过向VxWorks系统调用基础结构注册新的系统调用，使其可用于进程。

监控系统调用
VxWorks内核shell为监视系统调用提供了API。有关更多信息，请参阅VxWorks内核API引用中的系统监控器。

VxWorks库
VxWorks发行版包括为RTP应用程序提供API的函数库。这些功能中的一些在用户模式的过程中完全执行。其他的包装器函数进行一个或多个系统调用，或者为一个或多个系统调用添加附加功能。例如，printf() 是一个调用系统调用write()的包装器。printf()函数执行许多格式化等等，但最终必须调用write()将字符串输出到文件描述符。
不包含系统调用的库函数以完全用户模式执行，因此比包括内核陷阱开销的系统调用更高效。

Dinkum C和C++库
为VxWorks RTP应用程序开发提供了Dinkum C和C++库，包括嵌入式（简写）C++库。有关这些库的更多信息，请参见Dinkumware API引用。
VxWorks发行版还提供了类似于UNIX C运行时共享库的C运行时共享库特性。有关此库的信息，请参阅4.14VxWorks运行时C共享库libc.so，p.65.
有关C++开发的更多信息，请参见5。C++开发。

自定义库
应用程序创建自定义用户模式库的信息，请参见4。RTP库和插件。
API文档
有关应用程序中可用的函数的详细信息，请参阅VxWorks应用程序API引用和Dinkumware库引用。

3.6 RTP 环境变量