5.1关于VxWorks的C++支持
提供了支持风河Diab和GNU工具链的C++支持。默认情况下，为内核和RTP应用程序提供C++ 03支持。还提供了C++ 11支持作为RTP应用程序和共享库的替代。
C++头文件
每个编译器都有自己的C++库和C++头文件（如iostream和new）。C++标题位于编译器安装目录中。不需要特殊的标志来允许编译器找到这些标题。
SDA和C++代码警告
由PowerPC支持的小数据区域（SDA）重新定位不适用于C++代码。不要使用Wind River Diab编译器-Xsmall-const=8 -Xsmall-data=8选项或GNU -G8 -msdata=eabi选项。

5.2 C++编译器的差异
风河Diab C++编译器使用爱迪生设计组（EDG）C++前端。它完全符合ANSI C++标准。GNU编译器支持ANSI C++标准中描述的大部分语言特征。
有关Diab编译器和相关工具的完整文档，请参阅Wind River Diab编译器文档集。有关GNU编译器和相关工具的完整文档，请参阅GNU工具包用户指南。
警告：风河Diab编译器C++与GNU C++二进制文件不兼容。如果VxWorks包含由内核应用程序（链接或下载）使用的C++代码，那么这两个代码都必须使用相同的工具链构建。但是，如果只包含C代码，则不需要使用相同的编译器。并且不需要VxWorks和RTP应用程序使用相同的编译器，不管它们是否包含C++代码。
标准模板库（STL）
VxWorks的GNU STL端口在类级别是线程安全的。
Diab STL是线程安全的。
实例化
在C语言中，程序使用的每个函数和变量都必须精确地定义在一个地方（更精确地说是一个翻译单元）。然而，在C++中，实体没有明确的定义点，但仍然需要定义。其中包括模板专门化（泛型模板的特定实例；例如，std::vector int）、用于内联函数的离线主体，以及用于没有非内联虚拟函数的类的虚拟函数表。对于这些实体，源代码定义通常出现在头文件中，并且包含在多个翻译单元中。
为了处理这种情况，Wind River Diab编译器和GNU编译器在每个需要它的文件中都生成一个定义，并将每个这样的定义放在自己的部分中。Diab编译器为此使用COMDAT部分，而GNU编译器使用linkonce部分。在每种情况下，链接器都会删除重复的部分，结果是最终的可执行文件恰好包含每个所需实体的一个副本。
注意：对于内核代码，只有Wind River Diab编译器链接器可用于处理包含COMDAT部分的文件。类似地，只有GNU链接器可用于包含链接部分的文件。此外，VxWorks目标和主机加载程序不能处理COMDAT和链接部分。完全链接的VxWorks映像将不包含任何COMDAT或LIKONE段。然而，从C++代码编译的中间对象文件可以包含这样的部分。为了构建一个可下载的C++模块，或者一个可以由任何链接器处理的文件，您必须使用-R5选项（DIABR）或指定Link KOUT链接器脚本（GCC）来执行中间链接步骤。（注意，-r5和-r4选项（后者在本章的其他部分中提到）都折叠COMDAT文件，但是它们的总体用途不同，并且在单个链接器命令中它们的使用是互斥的。）
Wind River建议您使用模板实例化的默认设置，因为这些设置结合了易用性和最小代码大小。但是，可以更改模板实例化算法；有关详细信息，请参阅编译器文档。
风河DIABR编译器及模板的多重实例化
风河DIABC编译器控制多个模板实例的C++选项是：
-Xcomdat
这个选项是默认的。当隐式实例化模板时，生成的代码或数据部分被标记为comdat。然后，链接器将标记为相同的实例折叠到内存中的单个实例中。
注意：如果要使用代码作为可下载的内核模块，则必须使用-r4选项来折叠输入文件中包含的任何COMDAT部分。
-Xcomdat-off
在结果对象文件中生成模板实例化和内联函数作为静态实体。可以导致静态成员函数或类变量的多个实例。
为了更好地控制模板实例化，-Ximplicit-templates-off选项告诉编译器仅在源代码中显式调用的地方实例化模板；例如：
template class A<int>; // Instantiate A<int> and all member functions.
template int f1(int); // Instantiate function int f1{int).

GNU编译器多实例化的模板
GNU的C++编译器选项控制多实例化的模板是：
-fimplicit-templates
这是默认选项。模板的实例化和外行的副本（内联函数是把linkonce为特殊的部分。重复的部分是添加的链接，所以，每一次出现instantiated模板的输出文件。
警告：在VxWorks操作系统不支持动态加载linkonce直接切片的内核模块。而不是“linkonce切片和collapsed必须添加到标准文本和数据部分的前负荷。
-fno-implicit-templates
这是显式实例化。使用这个模板实例化策略没有任何你需要的。
运行时类型信息
编译器都支持的运行时类型信息（RTTI），和冰化特征的城市的默认。这一特征adds开销小，任何两个C++程序与含虚拟函数的类。
The Wind River Diab编译器RTTI的语言特征，可以用-Xrtti-off的旗帜。
GNU编译器RTTI的语言特征，可以用“没有禁止RTTI的旗帜。

