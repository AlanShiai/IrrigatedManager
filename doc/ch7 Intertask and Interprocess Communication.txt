7.1关于任务间和进程间通信112
VxWorks任务间和进程间工具提供了用于同步不同任务的活动以及用于它们之间的通信的机制。
对于进程间和内核进程通信，可以创建VxWorks信号量和消息队列、管道和事件（以及POSIX信号量和事件）作为公共对象，以提供跨内存边界（内核和进程之间，以及不同进程之间）的任务间通信耳鼻喉科手术）。
VxWorks提供了用于任务间和进程间通信的以下设施：
共享数据结构
提供在同一内存空间（内核或RTP）中执行的任务通过访问数据结构进行通信的方法。参见7.2个共享数据结构P.113。
中断锁（仅内核）
提供一种禁用中断的方法，从而防止ISRS抢占。中断锁定不是通用机制，应该只以非常有限的方式使用。参见7.3个中断锁，P.113。
任务锁（仅内核）
提供一种禁用其他任务抢占的方法。任务锁定不是一种通用机制，应该只以非常有限的方式使用。参见7.4个任务锁，P.114。
信号量
提供任务同步和互斥的主要手段。通用和特殊的变体是可用的，如7.5种类型的信号机，第115页。信号量可以被创建为公共对象，这允许它们在进程间通信中使用；关于这方面的信息，参见7.18进程间与公共对象的通信，第147页。有关POSIX信号量的信息，请参阅9.19个POSIX信号量表P.217。
消息队列
提供在任务之间直接通信消息的高级机制。参见7.12个消息队列，P.131。消息队列可以创建为公共对象，这允许它们在进程间通信中使用；关于这方面的信息，请参阅7.18进程间与公共对象的通信，第147页。
管
为消息队列设施提供另一个消息传递接口。管道通过I/O系统运行，允许使用标准的I/O功能和选择（）。见7.14个管道，P.136。
VxWorks事件
提供任务和其他任务、中断服务例程（ISR）和任务、信号量和任务、消息队列和任务之间的通信和同步方法。参见7.16个VxWorks事件，P.138。
VxWorks条件变量
提供基本的任务同步能力，它将对资源的线程安全访问与事件信令能力结合起来。参见7.17 VxWorks条件变量P.144。
有关不打算用于通用任务间和进程间通信的信号的信息，请参阅8.1 About Signals，p.152。
注意：除了少数例外，VxWorks的对称多处理器（SMP）和单处理器（UP）配置共享用于任务间和进程间通信的相同设施――差别仅相当于几个功能。有关VxWorks SMP的信息，请参见18。VxWorks SMP；有关迁移的具体信息，请参见VxWorks SMP的18.18代码迁移，p.449。

7.2共享数据结构113
在同一个内存空间（在单个进程或内核中）中执行的任务进行通信的最明显的方法是访问共享数据结构。
因为单个进程或内核中的所有任务都存在于单个线性地址空间中，所以在任务之间共享数据结构是微不足道的。
全局变量、线性缓冲区、环形缓冲区、链接列表和指针可以由在不同任务上下文中运行的代码直接引用。然而，对共享数据结构的访问应该使用诸如信号量之类的互斥来控制（参见7.5种类型的信号量，p.115）。

7.3中断锁113
在内核中，intLock()函数可用于禁用中断，从而防止ISR抢占。它可以从任务或ISR上下文调用。intUnLock（）函数可重启中断。
这些函数用于保护代码的关键区域如下：
foo ()
{
int lockKey = intLock();
.
. /* critical region of code that cannot be interrupted */
.
intUnlock(lockKey);
}
当任务正在访问ISR也访问的变量或数据结构时，使用intLock()来防止抢占。操作应该是最小的，这意味着几行代码和没有函数调用。如果调用太长，则会直接影响中断等待时间，并使系统变得不那么确定性。
为了防止任务和ISR抢占任务，请同时使用intLock()和taskLock()；有关这方面的更多信息，请参阅intLock()的API引用条目。
有关ISRS的信息，请参阅8.7关于中断服务例程：ISRs，P.163。
警告：在锁定中断的情况下调用VxWorks系统功能可能会导致中断在未指定的时间内被重新启用。如果被调用的函数阻塞，或者导致更高优先级的任务变得有资格执行（READY），则在另一个任务执行时或内核空闲时重新启用中断。有关这方面的更多信息，请参见intLock（）的API引用条目。
注意：intLock()函数是为VxWorks的UP配置提供的，但不是SMP配置。SMP系统有几种可选方案，包括ISR可调用自旋锁，它在UP系统中默认为intLock()行为。有关更多信息，请参阅ISR-Callable Spinlocks，p.423和18.18，VxWorks SMP的代码迁移，p.449。

7.4任务锁114
在内核中，TaskLock（）函数禁用调用任务的抢占其他任务。
调用任务是只有在就绪状态下才允许执行的唯一任务。如果调用任务阻塞或挂起，则调度程序选择下一个最高优先级的合格任务来执行。当调用任务解除阻塞并恢复执行时，再次禁用抢占。（有关任务状态的信息，请参阅6.4Task States and.tions，p.82。）taskUnlock()函数可重新启用其他任务的抢占。
任务锁函数用于保护代码的关键区域如下：
foo()
{
taskLock();
.
. /* critical region of code that cannot be interrupted */
.
taskUnlock();
}
任务锁可以嵌套（它们使用count变量实现），在这种情况下，直到taskUnlock()被调用了taskLock()的次数，才重新启用抢占。
任务锁会导致不可接受的实时响应时间。较高优先级的任务在锁定任务离开关键区域之前无法执行，即使较高优先级的任务本身不涉及关键区域。虽然这种互斥很简单，但一定要保持持续时间短。通常，信号量为互斥提供了更好的机制；参见7.5种类型的信号量，p.115。
当使用taskLock()时，不会阻塞中断，但它可以与intLock()配对以禁用任务和ISR的抢占。
有关更多信息，请参见taskLock（）和taskUnLock（）的API引用条目。
注意：taskLock()和taskUnlock()函数是为VxWorks的UP配置提供的，而不是SMP配置。SMP系统可以使用几种替代方法，包括只任务自旋锁，在UP系统中默认为taskLock()和taskUnlock()行为。有关更多信息，请参阅VxWorks SMP的仅任务自旋锁，p.425和18.18代码迁移，p.449。

7.5种信号量115
VxWorks信号量是高度优化的，提供了一种非常快的任务间通信机制。信号量是处理互斥和任务同步需求的主要手段。
为了互斥，信号灯互锁访问共享资源。在内核中，它们提供了比锁定中断或任务更细粒度的相互排斥（参见7.3中断锁，p.113和7.4任务锁，p.114）。
对于同步，信号量与外部事件协调任务的执行。
注意：信号量提供完整的内存屏障，这对于VxWorks的SMP配置特别重要。欲了解更多信息，请参阅18.7内存障碍，P.429。
VxWorks提供下列类型的信号量，它们针对不同类型的使用进行了优化：
二进制
最快、最通用的信号量。同步或互斥优化。有关更多信息，请参阅7.7个二进制信号量P.120。
互斥
针对互斥中固有的问题优化的特殊二进制信号量：优先级反转、删除安全性和递归。有关更多信息，请参见7.8个互斥信号量，P.123。
计数
和二进制信号量一样，但要保持信号量的次数。优化用于保护资源的多个实例。有关更多信息，请参见7.9计数信号量，P.128。
读/写
一种特殊类型的信号量，为需要对对象进行写访问的任务提供互斥，并为仅需要对对象进行读访问的任务提供并发访问。这种信号量对于SMP系统特别有用。有关更多信息，请参见7.10个读/写信号量，P.128。
VxWorks不仅提供专门为VxWorks设计的信号量，还提供为可移植性设计的POSIX信号量。另一个信号量库提供了与POSIX兼容的信号量接口；参见9.19POSIX Semaphores，p.217。

7.6信号量的创建和使用116
7.7个二进制信号量120
7.8互斥信号量123
7.9计数信号灯128
7.10个读/写信号量128
7.11个特殊信号量选项130
7.12个消息队列131
7.13消息创建和使用132
7.14管道136
7.15管道的创建和使用137
7.16个VxWorks事件138
7.17 VxWorks条件变量144
7.18与公共对象的进程间通信 147
7.19关于VxWorks API超时参数149
7.20关于对象所有权和资源回收149